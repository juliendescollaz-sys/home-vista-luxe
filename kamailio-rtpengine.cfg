#!KAMAILIO
#
# Kamailio SIP Server with RTPEngine for WebRTC bridging
#

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

#!define WITH_NAT
#!define WITH_TLS
#!define WITH_WEBSOCKET
#!define WITH_RTPENGINE

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* number of SIP routing processes */
children=8

/* add local domain aliases */
alias="sip.neolia.app"

listen=udp:141.227.158.64:5060
listen=tcp:141.227.158.64:5060
listen=tcp:141.227.158.64:5080
listen=tls:141.227.158.64:8443

#!ifdef WITH_TLS
enable_tls=yes
#!endif

/* life time of TCP connection when there is no traffic */
tcp_connection_lifetime=3605

#!ifdef WITH_WEBSOCKET
tcp_accept_no_cl=yes
tcp_rd_buf_size=16384
#!endif

####### Modules Section ########

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "sdpops.so"

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#!endif

#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_WEBSOCKET
loadmodule "xhttp.so"
loadmodule "websocket.so"
#!endif

# ----------------- setting module-specific parameters ---------------

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_contacts", 2)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)

# ----- usrloc params -----
modparam("usrloc", "db_mode", 0)

#!ifdef WITH_NAT
# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_RTPENGINE
# ----- rtpengine params -----
# Socket de controle vers rtpengine
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

####### Routing Logic ########

request_route {
	# per request initial checks
	route(REQINIT);

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# record routing for dialog forming requests
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
		record_route();
	}

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC);
	}

	# dispatch requests to foreign domains
	route(SIPOUT);

	# handle registrations
	route(REGISTRAR);

	if ($rU==$null) {
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	# user location service
	route(LOCATION);
}

# Wrapper for relaying requests
route[RELAY] {
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
	if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("17895", "7")) {
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	if (loose_route()) {
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC);
			setflag(FLT_ACCFAILED);
		} else if ( is_method("ACK") ) {
			route(NATMANAGE);
		} else if ( is_method("NOTIFY") ) {
			record_route();
		}
		route(RELAY);
		exit;
	}

	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			route(RELAY);
			exit;
		} else {
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")) return;

	if(isflagset(FLT_NATS)) {
		setbflag(FLB_NATB);
	}
	if (!save("location")) {
		sl_reply_error();
	}
	exit;
}

# User location service
route[LOCATION] {
	$avp(oexten) = $rU;
	if (!lookup("location")) {
		$var(rc) = $rc;
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}

	if (is_method("INVITE")) {
		setflag(FLT_ACCMISSED);
	}

	route(RELAY);
	exit;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	force_rport();
	if (nat_uac_test("83")) {
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# RTPEngine control for NAT traversal and WebRTC bridging
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

#!ifdef WITH_RTPENGINE
	# Detecter si c'est un client WebSocket (WebRTC)
	if ($proto == "ws" || $proto == "wss") {
		# Client WebRTC: besoin de DTLS-SRTP et ICE
		xlog("L_INFO", "NATMANAGE: WebRTC client detected, using RTPEngine with ICE+DTLS\n");
		if (is_request()) {
			rtpengine_manage("replace-session-connection replace-origin ICE=force DTLS=passive SDES-off");
		} else {
			rtpengine_manage("replace-session-connection replace-origin ICE=force DTLS=passive SDES-off");
		}
	} else {
		# Client SIP classique (UDP/TCP): RTP simple
		xlog("L_INFO", "NATMANAGE: Classic SIP client, using RTPEngine without ICE/DTLS\n");
		if (is_request()) {
			rtpengine_manage("replace-session-connection replace-origin");
		} else {
			rtpengine_manage("replace-session-connection replace-origin");
		}
	}
#!endif

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB) || nat_uac_test("64")) {
			if(is_first_hop())
				set_contact_alias();
		}
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}

# Routing to foreign domains
route[SIPOUT] {
	if (uri==myself) return;

	append_hf("P-hint: outbound\r\n");
	route(RELAY);
	exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE);

	if (t_is_canceled()) exit;
}

#!ifdef WITH_WEBSOCKET
event_route[xhttp:request] {
	set_reply_close();
	set_reply_no_connect();
	if ($hdr(Upgrade)=~"websocket"
			&& $hdr(Connection)=~"Upgrade"
			&& $rm=~"GET") {

		if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
			xlog("L_WARN", "Bad host $hdr(Host)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}
		if (ws_handle_handshake()) {
			exit;
		}
	}
	xhttp_reply("404", "Not Found", "", "");
}
#!endif
